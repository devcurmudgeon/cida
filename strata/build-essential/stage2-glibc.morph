name: stage2-glibc
kind: chunk

configure-commands:
- mkdir o

# Configure flag notes:
#   1. Avoid installing to PREFIX/lib64 on x86_64.
#   2. Location of linux-api-headers.
#   3. Normal flags. See glibc.morph.
#   4. Force configuration values of certain things that can't be detected
#      in a cross-compile.
- |
  case "$MORPH_ARCH" in
      armv7*)
          ARCH_FLAGS="--without-fp" ;;
  esac

  export CFLAGS="-O2 $CFLAGS"; export CXX=false; \
  cd o && ../configure \
    $ARCH_FLAGS \
    --build=$(../scripts/config.guess) --host=$TARGET_STAGE1 \
    --prefix="$PREFIX" \
    --enable-obsolete-rpc \
    `# [1]` --libdir="$PREFIX/lib" \
    `# [2]` --with-headers="$(pwd)/../../$PREFIX/include" \
    `# [3]` --disable-profile  --enable-kernel=2.6.25 \
    `# [4]` libc_cv_c_cleanup=yes libc_cv_ctors_header=yes \
            libc_cv_forced_unwind=yes libc_cv_ssp=no

build-commands:
- cd o && make localtime=UTC

install-commands:
- cd o && make install_root="$DESTDIR" localtime=UTC install
- mkdir -p "$DESTDIR/etc"
- |
  cat <<EOF > ld.so.conf
  /lib
  /usr/lib
  /usr/local/lib
  include /etc/ld.so.conf.d/*.conf
  EOF
- install -m 644 -o root -g root ld.so.conf "$DESTDIR/etc/ld.so.conf"
- |
  # Fix up GCC to handle the sysroot containing glibc being in a different
  # location for each chunk build.
  #
  # For headers, it's enough to pass -B in the CPPFLAGS. This would work for
  # the startup files (crt*.o) as well, except where libtool is involved (in
  # which case it strips -B out of your LDFLAGS before calling GCC). We get
  # around this by making GCC locate them relative to the environment variable
  # STAGE2_SYSROOT, which we can then set along with CPPFLAGS in each stage 2
  # chunk build.
  #
  # We also force the use of the program loader at PREFIX/lib/ld.so instead
  # of its usual home in /lib or /lib64, which is necessary for the output of
  # stage 2 to work as a chroot when building stage 3.

  sysroot="$(dirname "$(pwd)")"
  specs_dir="$(dirname $($TARGET_STAGE1-gcc --print-libgcc-file-name))"
  target_specs_dir="$DESTDIR/${specs_dir#$sysroot}"
  mkdir -p "$target_specs_dir"

  $TARGET_STAGE1-gcc -dumpspecs |
      sed -e "s@[gMS]\?crt[1in].o%s@%:getenv(STAGE2_SYSROOT $PREFIX/lib/&)@g" \
          -e "s@/lib\(64\)\?/ld@$PREFIX/lib/ld@g" \
      > "$target_specs_dir/specs-for-sysroot"

  # NASTY HACK #
  # We create a symlink to the actual specs here, so that later the
  # symlink can be replaced with a dangling link.
  #
  # This is necessary as we need to have gcc use its internal specs,
  # which can differ to the specs generated by `gcc -dumpspecs`.
  #
  # The dangling symlink will not make it onto the final system, just
  # like all other bootstrap only components.
  ln -s specs-for-sysroot "$target_specs_dir/specs"

# Install a symlink for the program interpreter (ld.so) so that binaries
# built in stage 3 before the stage 3 glibc is built can use it.
# FIXME: get a better way of finding the name of the loader. The lib64
# path is hardcoded into glibc in the file
# sysdeps/unix/sysv/linux/configure.
- install -d $DESTDIR/lib
- |
  cpu=$(echo $TARGET | cut -d '-' -f 1)
  case "$cpu" in
  x86_64)
    install -d "$DESTDIR/lib64"
    ln -s "$PREFIX/lib/ld-linux-x86-64.so.2" \
          "$DESTDIR/lib64/ld-linux-x86-64.so.2" ;;
  ppc64)
    install -d "$DESTDIR/lib64"
    ln -s "$PREFIX/lib/ld64.so.1" \
          "$DESTDIR/lib64/ld64.so.1" ;;
  *)
    loader=$(basename $(ls "$DESTDIR$PREFIX"/lib/ld-linux*))
    [ -z $loader ] && loader=$(basename $(ls "$DESTDIR$PREFIX"/lib/ld.so*))
    [ -z $loader ] && ( echo "Bug in stage2-glibc ld.so symlinks" ; exit 1 )
    ln -s "$PREFIX/lib/$loader" "$DESTDIR/lib/$loader"
  esac
